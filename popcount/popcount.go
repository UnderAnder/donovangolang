package popcount

import (
	"fmt"
)

// pc[i] - количество единичный битов в i
var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
		//fmt.Println(pc[i])
	}
}

// PopCount возвращает степень заполнения
// (количество установленных битов) значения х.
func PopCount(x uint64) int {
	return int(pc[byte(x>>(0*8))] + pc[byte(x>>(1*8))] + pc[byte(x>>(2*8))] + pc[byte(x>>(3*8))] + pc[byte(x>>(4*8))] + pc[byte(x>>(5*8))] + pc[byte(x>>(6*8))] + pc[byte(x>>(7*8))])
}

/* TODO: Упражнение 2.3. Перепишите функцию PopCount так, чтобы она использовала
цикл вместо единого выражения. Сравните производительность двух версий. (В раз­
	деле 11.4 показано, как правильно сравнивать производительность различных реали­
	заций.)
	Упражнение 2.4. Напишите версию PopCount, которая подсчитывает биты с по­
	мощью сдвига аргумента по всем 64 позициям, проверяя при каждом сдвиге крайний
	справа бит. Сравните производительность этой версии с выборкой из таблицы.
	Упражнение 2.5. Выражение х&(х-1) сбрасывает крайний справа ненулевой
	бит х. Напишите версию PopCount, которая подсчитывает биты с использованием
	этого факта, и оцените ее производительность.*/
func main() {
	fmt.Println(PopCount(342))
}
